#!/usr/bin/env bash

# **_A shell script to deploy Git repositories._**
#
# * **Source:** https://github.com/AlphaHydrae/deploy
# * **Originally by:** https://github.com/visionmedia/deploy

VERSION="1.0.1"





# ## Usage
usage() {
  cat <<-EOF

  Usage: deploy [options] <env> <command>

  Options:

    -C, --chdir <path>    change the working directory to <path>
    -c, --config <path>   set config path. defaults to ./deploy.conf
    -V, --version         output program version
    -h, --help            output help information

  Commands:

    <env> setup              run remote setup commands
    <env> ref [ref]          deploy a release (commit, branch or tag)
    [env] config [key]       output config file, a section, or one value
    <env> config-all [key]   output all values of a config key in an environment
    <env> console [path]     open an ssh session to the host
    <env> exec <cmd>         execute the given command on the host
    <env> list               list previous deploy commits
    update                   update this script to the latest version

  Examples:

    deploy prod setup             run remote setup in the prod env
    deploy dev ref master         deploy the master branch in the dev env
    deploy prod exec pm2 status   run 'pm2 status' in the prod env
    deploy dev config user        get the value of the user key in the dev env

EOF
}





# ## Sub-commands

# ### `<env> setup`
#
# Perform first-time setup tasks before deployment.
setup() {
  require_env

  local path="$(get_last_config_value path)"
  local repo="$(get_last_config_value repo)"

  # Run user-defined `pre-setup` hooks (if any).
  run_hooks pre-setup "$path"

  # Create the `releases` and `tmp` directories in the deployment directory
  # if they don't already exist.
  log running setup
  run "{ test -d $path || exit 1; } \
       && mkdir -p $path/releases $path/tmp" \
    || abort "failed to set up directories; make sure $path exists and is writable"

  # Clone the repository into `repo` in the deployment directory
  # if it isn't already there.
  log cloning repo
  run "test -d $path/repo \
       || { git clone --bare $repo $path/repo || exit 1; }" \
    || abort "failed to clone repo"

  # Run user-defined `post-setup` hooks (if any).
  run_hooks post-setup "$path"

  log setup complete
}

# ### `<env> ref [ref]`
#
# Deploys the latest changes from the repository.
deploy_ref() {
  require_env
  require_no_local_changes

  local path=`get_last_config_value path`
  local release=`date -u '+%Y-%m-%d-%H-%M-%S'`
  local current_dir="$path/current"
  local release_dir="$path/releases/$release"
  local tmp_dir="$path/tmp"

  # A Git reference to a commit, branch or tag is required,
  # either from the command line argument or from a `ref` key in the configuration file.
  local ref=${1:-`get_last_config_value ref`}
  test -n "$ref" || abort "no commit, branch or tag specified"

  log deploying
  echo "    ref: $ref"
  echo "    release: $release"

  # Run user-defined pre-deploy hooks (if any).
  run_hooks pre-deploy $current_dir

  # Fetch the latest changes from the repository (from the specified ref).
  log fetching updates
  run "cd $path/repo \
       && git fetch origin '+refs/heads/*:refs/heads/*' \
       && git rev-list -n 1 $ref" \
    || abort "could not fetch changes"

  # Extract the sources at the specified ref into the `releases` directory.
  log "extracting source at $ref"
  run "cd $path/repo \
       && mkdir -p $release_dir \
       && git archive --output $tmp_dir/release-$release.tar $ref \
       && tar -C $release_dir -x --file $tmp_dir/release-$release.tar \
       && rm -f $tmp_dir/release-*.tar" \
    || abort "could not extract source from repository"

  # Run user-defined deploy hooks (if any).
  run_hooks deploy $release_dir

  # Link the `current` directory to the new release.
  log linking current
  run "ln -fns $release_dir $current_dir" \
    || abort "could not create current symlink"

  # Run user-defined post-deploy hooks (if any).
  run_hooks post-deploy $current_dir

  log successfully deployed
}

# ### `[env] config [key]`
#
# Prints configuration values.
#
#     # deploy.conf
#     []
#     user dev
#
#     [production]
#     user root
#     port 222
config() {
  # If called with **no environment and no arguments**, print the whole configuration file:
  #
  # ```sh
  # # shell
  # deploy config
  # #=> []
  # #=> user dev
  # #=>
  # #=> [production]
  # #=> user root
  # #=> port 222
  # ```
  if test $# -eq 0; then
    if test -z "$DEPLOY_ENV"; then
      cat "$DEPLOY_CONFIG"

    # If **preceded by the environment**, print all values in that section:
    #
    # ```sh
    # # shell
    # deploy production config
    # #=> user root
    # #=> port 222
    # ```
    else
      get_config_section "$DEPLOY_ENV"
    fi

  # If called with **the environment and a key**, print the last value of that key in that section:
  #
  # ```sh
  # # shell
  # deploy production config user
  # #=> root
  # ```
  else
    get_last_config_value $1
  fi
}

# ### `<env> config-all <key>`
#
# Outputs all values of a config key in the current environment and its inherited environments.
#
#     # deploy.conf
#     []
#     user dev
#
#     [production]
#     user root
#     port 222
#
# ```sh
# # shell
# deploy production config-all user
# #=> dev
# #=> root
# ```
config_all() {
  require_env
  get_all_config_values "$1"
}

# ### `<env> console [path]`
#
# Launches an interactive ssh console session.
console() {
  require_env

  # If an **absolute path** is given, the session starts there.
  local path="$1"

  # If **no path** is given, the session starts in the deployment directory.
  if test -z "$path"; then
    path="$(get_last_config_value path)"

  # If a **relative path** is given, it starts there relative to the deployment directory.
  elif [[ ! "$path" =~ ^\/ ]]; then
    path="$(get_last_config_value path)/$path"
  fi

  test -n "$path" || abort "path is required"

  local shell="`build_ssh_command`"
  echo $shell
  $shell -t "cd $path; \$SHELL -il"
}

# ### `<env> exec <cmd>`
#
# Executes the specified command on the host.
#
# ```sh
# deploy production exec ps -ef
# ```
exec_remote_command() {
  require_env
  local path="$(get_last_config_value path)"
  run "cd $path && $(build_export_env_command) && $@"
}

# ### `<env> list`
#
# Lists the releases that have been deployed on the host.
#
# ```sh
# $> deploy production list
# 2016-12-24-17-45-23
# 2017-01-01-02-03-43
# 2017-04-01-00-00-00
# ```
list_releases() {
  require_env
  local path=`get_last_config_value path`
  run "ls -1 $path/releases"
}

# ### `update [--prefix dir] [--path path] [ref]`
#
# Updates this script to the latest version by downloading it from the Git repository.
update_self() {
  local ref=
  local path=
  local prefix=/usr/local

  # This sub-command requires additional shell commands to be available.
  require_command chmod cp mktemp

  while test $# -ne 0; do
    arg=$1; shift
    case $arg in
      # If a `--prefix` directory is specified, the script will be installed
      # at `bin/deploy` relative to that directory.
      --prefix) prefix="$1"; shift ;;
      # If a `--path` file is specified, the script will be installed there
      # (this overrides the `--prefix` option).
      --path) path="$1"; shift ;;
      # The first optional argument is the Git revision from which to download the script.
      # This defaults to `master`.
      *)
        if test -z "$ref"; then
          ref="$arg"
        else
          abort "unknown command or option $arg"
        fi
        ;;
    esac
  done

  test -z "$path" && path=$prefix/bin/deploy

  # The installation path must be a writable file or not exist.
  test -e "$path" && ! test -f "$path" && abort "$path already exists and is not a file"
  test -f "$path" && ! test -w "$path" && abort "$path is not writable"

  # If the installation path does not already exist, its parent must be a writable directory.
  local dir="$(dirname "$path")"
  test -f "$path" || test -e "$dir" || abort "$dir does not exist"
  test -f "$path" || test -d "$dir" || abort "$dir is not a directory"
  test -f "$path" || test -w "$path" || abort "$dir is not writable"

  test -z "$ref" && ref=master
  log "updating deploy from $ref @ $DEPLOY_UPDATE_REPO"

  # The Git repository is downloaded in a temporary directory that will be cleaned up when the update is done (or fails).
  local tmp_dir=`mktemp -d -t deploy`
  trap "cleanup $tmp_dir" EXIT

  # Once the Git directory is cloned, the correct revision of the script is copied to the installation path and made executable.
  cd "$tmp_dir" \
    && git clone $DEPLOY_UPDATE_REPO "$tmp_dir" || abort could not clone $DEPLOY_UPDATE_REPO \
    && { git rev-parse --verify $ref &>/dev/null && git reset --hard $ref || { git fetch origin $ref && git reset --hard origin/$ref; }; } || abort could not find $ref \
    && cp bin/deploy $path \
    && chmod +x /usr/local/bin/deploy \
    || abort could not update deploy

  log "updated $VERSION -> `./bin/deploy --version`"
}





# ## General options

# ### `--config <path>`
#
# `./deploy.conf` is used as the configuration file by default.
# Use this option or the `$DEPLOY_CONFIG` environment variable to load a different file.
#
# The command line option takes precedence over the environment variable.
set_config_path() {
  local file="$1"
  test -e "$file" || abort "invalid config file: $file does not exist"
  test -f "$file" || abort "invalid config file: $file is not a file"
  test -r "$file" || abort "invalid config file: $file cannot be read"
  DEPLOY_CONFIG="$file"
}

# ### `--version`
#
# Prints the current version and exits.
version() {
  echo $VERSION
}





# ## Internal implementation

# ### `config_section_exists $env`
#
# Checks whether the config file contains a section with the specified name.
# Returns a non-zero status code if it doesn't.
#
#     # deploy.conf
#     [development]
#     host example
#
# ```sh
# # script
# config_section_exists development
# echo $? #=> 0
# config_section_exists production
# echo $? #=> 1
# ```
config_section_exists() {
  grep "^\[$1\]$" "$DEPLOY_CONFIG" &> /dev/null
}

# ### `get_config_env_var $key`
#
# Gets the environment variable that can be used to add
# a value to the specified config key.
#
# ```sh
# # script
# get_config_env_var path
# #=> DEPLOY_PATH
# get_config_env_var post-setup
# #=> DEPLOY_POST_SETUP
# ```
get_config_env_var() {
  local key=$1
  echo "DEPLOY_$key" | tr '-' '_' | tr '[a-z]' '[A-Z]'
}

# ### `get_last_config_value $key`
#
# Gets the last value of a config key in the current environment and its inherited environments.
#
#     # deploy.conf
#     []
#     user dev
#
#     [production]
#     user root
#
# ```sh
# # script
# get_last_config_value host production
# #=> root
# ```
get_last_config_value() {

  local key=$1
  local env_var=$(get_config_env_var $key)

  local env_var_value=${!env_var}
  if [ -n "$env_var_value" ]; then
    echo "$env_var_value"
  else
    test -n "$key" \
      && get_all_config_values "$key" \
      | tail -n 1
  fi
}

# ### `get_all_config_values $key`
#
# Gets all values of a config key in the current environment and its inherited environments.
#
#     # deploy.conf
#     [development]
#     deploy do-stuff
#     deploy do-more-stuff
#     deploy just-do-it
#
# ```sh
# # script
# get_all_config_values deploy development
# #=> do-stuff
# #=> do-more-stuff
# #=> just-do-it
# ```
get_all_config_values() {

  local env=$DEPLOY_ENV
  local key=$1

  test -n "$env" \
    && test -n "$key" \
    && get_config_values_recursive $key $env
}

# ### `get_config_values_recursive $key $env`
#
# Recursively gets all values of a config key for an environment and its inherited environments.
# Used by `get_all_config_values`.
#
#     # deploy.conf
#     []
#     deploy do-stuff
#
#     [common]
#     deploy do-more-stuff
#     deploy do-stuff-again
#
#     [shared]
#     inherits common
#     deploy do-shared-stuff
#
#     [development]
#     inherits common
#     inherits shared
#     deploy just-do-it
#
# ```sh
# # script
# get_config_values_recursive deploy development
# #=> do-stuff
# #=> do-more-stuff
# #=> do-stuff-again
# #=> just-do-it
# ```
get_config_values_recursive() {

  local key="$1"
  local env="$2"
  local values=

  if ! config_section_exists $env; then
    log_error "    [$env] config section not defined"
    exit 0
  fi

  local new_line=$'\n'
  local old_ifs=$IFS
  IFS=$'\n'

  local inherits="$(get_config_values_in_env inherits $env)"
  for inherit_env in $inherits; do
    IFS="$old_ifs"

    local new_values="$(get_config_values_recursive $key $inherit_env)"
    if test -n "$new_values"; then
      [ -n "$values" ] && values="$values$new_line"
      values="$values$new_values"
    fi

    IFS=$'\n'
  done

  IFS="$old_ifs"

  if test -z "$inherits"; then
    local top_level_values="$(get_config_values_in_env $key)"
    if test -n "$top_level_values"; then
      [ -n "$values" ] && values="$new_line$values"
      values="$top_level_values$values"
    fi
  fi

  local current_level_values="$(get_config_values_in_env $key $env)"
  if test -n "$current_level_values"; then
    [ -n "$values" ] && values="$values$new_line"
    values="$values$current_level_values"
  fi

  echo "$values"
}

# ### `get_config_values_in_env $key $env`
#
# Gets all values of a config key for an environment:
#
#     # deploy.conf
#     [development]
#     host foo
#     port 42
#     host bar
#
# ```sh
# # script
# get_config_values_in_env host development
# #=> foo
# #=> bar
# ```
get_config_values_in_env() {

  local key="$1"
  local env="$2"

  get_config_section $env \
    | grep "^$key " \
    | cut -d ' ' -f 2-999
}

# ### `get_config_section $env`
#
# Gets all key/value pairs in a config section, with all comments and empty lines omitted:
#
#     # deploy.conf
#     [development]
#
#     host foo
#     # SSH port
#     port 42
#     user dev
#
# ```sh
# # script
# get_config_section development
# #=> host foo
# #=> port 42
# #=> user dev
# ```
get_config_section() {

  local env="$1"

  grep "^\[$env\]$" -A 999 "$DEPLOY_CONFIG" \
    | tail -n +2 \
    | grep -v "^ *#" \
    | grep -v "^ *$" \
    | sed "/^\[/q" \
    | sed "/^\[/d"
}

# ### `hooks $name $host_cwd`
#
# Executes all user-defined hooks of the specified name in the current environment.
run_hooks() {

  local name=$1
  test -n "$name" || abort hook name required

  # The command are run in the specified working directory on the host.
  local dir=$2
  test -n "$dir" || abort hook working directory required

  local path=`get_last_config_value path`
  local commands=`get_all_config_values $name`

  log hook $name

  # Nothing is done if no hooks are defined.
  if test -z "$commands"; then
    echo "    nothing to do"
    return 0
  fi

  local old_ifs=$IFS
  IFS=$'\n'

  for cmd in $(echo "$commands"); do
    IFS="$old_ifs"

    # Various environment variables are exported before executing each hook,
    # `$DEPLOY_PATH` indicating the deployment directory (not necessarily the same
    # as the hook working directory), and any additional user-defined variables.
    # See `build_export_env_command`.
    run "cd $dir \
         && $(build_export_env_command) \
         && $cmd 2>&1" \
      || abort $name hook failed

    IFS=$'\n'
  done

  IFS="$old_ifs"
}

# ### `build_ssh_command`
#
# Builds an SSH command to connect to the host.
build_ssh_command() {
  # Various SSH options can be given through the config file or environment variables.
  # The `host` config (or `$DEPLOY_HOST` variable) is the only mandatory one.
  local host=$(get_last_config_value host)
  test -n "$host" || abort "no host config found in environment $DEPLOY_ENV"

  local url=$host

  # Specify the user to connect to the host as with the `user` config or the `$DEPLOY_USER` variable.
  local user=$(get_last_config_value user)
  test -n "$user" && url="$user@$url"

  # Supply a private key (identity file) with the `key` config or the `$DEPLOY_KEY` variable.
  local key="`get_last_config_value key`"
  test -n "$key" && key="-i $key"

  # Enable agent forwarding with the `forward-agent` config or the `$DEPLOY_FORWARD_AGENT` variable.
  local forward_agent="`get_last_config_value forward-agent`"
  test -n "$forward_agent" && forward_agent="-A"

  # Specify the host port to connect to with the `port` config or the `$DEPLOY_PORT` variable.
  local port="`get_last_config_value port`"
  test -n "$port" && port="-p $port"

  # Force pseudo-terminal allocation with the `tty` key or the `$DEPLOY_TTY` variable.
  local tty="`get_last_config_value tty`"
  test -n "$tty" && tty="-t"

  echo "ssh $tty $forward_agent $port $key $url"
}

# ### `run $@`
#
# Runs the specified command on the host through SSH.
run() {
  local shell="`build_ssh_command`"
  echo_command "$@"
  $shell $@
}

# ### `build_export_env_command`
#
# Returns a command to run on the host to export environment variables for further command execution.
build_export_env_command() {

  # The `$DEPLOY_PATH` variable is always exported and indicates the deployment directory
  # configured by the user with the `path` config or the local `$DEPLOY_PATH` variable.
  local path="$(get_last_config_value path)";
  local env_command="export DEPLOY_PATH=$path"

  # Additional variables may be exported by the user with the `env` config in the form `env FOO=BAR`.
  env_command="$command $(echo `get_all_config_values env`|sed 's/\n/ /g')"

  # Local variables may also be exported on the host with the `forward-env` config in the form `forward-env BAZ`.
  for forward_env in $(echo `get_all_config_values forward-env`|sed 's/\n/ /g'); do
    env_command="$env_command $forward_env=$(echo "${!forward_env}"|sed 's/ /\\ /g')"
  done

  echo "$env_command"
}

# ### `require_env`
#
# Ensures that an environment has been selected by providing an argument before the command to run.
# This is required for most (but not all) sub-commands. See `main`.
require_env() {
  test -n "$DEPLOY_ENV" || abort "<env> required"
  # It also ensures that the config file contains a section for that environment.
  config_section_exists $DEPLOY_ENV || abort "[$DEPLOY_ENV] config section not defined"
}

# ### `require_no_local_changes`
#
# Ensures that all changes are committed and pushed before deploying.
require_no_local_changes() {
  git --no-pager diff --exit-code --quiet || abort "commit or stash your changes before deploying"
  git --no-pager diff --exit-code --quiet --cached || abort "commit your staged changes before deploying"
  [ -z "`git rev-list @{upstream}.. -n 1`" ] || abort "push your changes before deploying"
}

# ### `command_exists $command`
#
# Checks whether the specified command exists.
command_exists() {
  command -v "$1" >/dev/null 2>&1
}

# ### `require_command $command`
#
# Ensures that the specified command exists.
require_command() {
  command_exists "$1" || abort "$1 command not found"
}

# ### `check_requirements`
#
# Ensures that all commands required for the execution of this script exist.
# Some optional commands are not checked here. See `update_self`.
check_requirements() {
  for com in cat cut date git grep ls mkdir sed ssh tail tar; do
    require_command $com
  done
}

# ### `make_temporary_directory`
#
# Creates a temporary directory that will be cleaned up when this script exits.
make_temporary_directory() {
  DEPLOY_TMP_DIR="$(mktemp -d -t deploy)"
  echo "$DEPLOY_TMP_DIR"
}

# ### `cleanup [$dir]`
#
# Removes the specified directory if an argument is specified and it is an existing directory.
cleanup() {
  local tmp_dir="$1"
  test -n "$tmp_dir" && test -d "$tmp_dir" && rm -fr "$tmp_dir"
}

# ### `abort $message`
#
# Aborts execution of this script with the specified message.
# The script exists with status code 1.
abort() {
  echo
  log_error "  $@"
  echo
  exit 1
}

# ### `log $message`
#
# Logs a deployment progress message.
log() {
  echo
  echo_color $COLOR_BOLD "  ○ $@"
}

# ### `log_command $message`
#
# Logs a command that is being executed on the host.
log_command() {
  echo_color $COLOR_YELLOW "$@" | tr -s ' ' | sed 's/^/    /'
}

# ### `log_error $message`
#
# Logs an error.
log_error() {
  echo_color $COLOR_RED "$@" 1>&2
}

# ### `echo_color $color $message`
#
# Prints a message in the specified color.
echo_color() {
  local color="$1"
  shift
  local message="$@"
  echo -e "\033[${color}m${message}\033[0m"
}

# ## Main command
COLOR_BOLD=1
COLOR_RED=31
COLOR_YELLOW=33

# Exit immediately if requirements are not met.
check_requirements

# If an `.env` file is present in the current directory, it is sourced before running any commands.
test -f .env && { test -r .env || abort "environment file .env is not readable"; }
test -f .env && { . .env || abort "an error occurred while sourcing .env"; }

DEPLOY_ENV=

# The configuration file defaults to `./deploy.conf`.
test -z "$DEPLOY_CONFIG" && DEPLOY_CONFIG=./deploy.conf

# The repo to update the script from defaults to `git://github.com/AlphaHydrae/deploy.git`.
test -z "$DEPLOY_UPDATE_REPO" && DEPLOY_UPDATE_REPO=git://github.com/AlphaHydrae/deploy.git

while test $# -ne 0; do
  arg=$1; shift
  case $arg in
    -h|--help) usage; exit ;;
    -V|--version) version; exit ;;
    -c|--config) set_config_path $1; shift ;;
    -C|--chdir) log cd $1; cd $1; shift ;;
    exec) exec_remote_command $@; exit ;;
    console) console $1; exit ;;
    setup) setup $@; exit ;;
    list) list_releases; exit ;;
    ref) deploy_ref $1; exit ;;
    update) update_self $@; exit ;;
    config) config $@; exit ;;
    config-all) config_all $@; exit ;;
    *)
      if test -z "$DEPLOY_ENV"; then
        DEPLOY_ENV=$arg;
      else
        abort "unknown command or option $arg"
      fi
      ;;
  esac
done

usage
abort "no command given"
