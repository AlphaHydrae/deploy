#!/usr/bin/env bash

# **_A shell script to deploy Git repositories._**
#
# * **Source:** https://github.com/AlphaHydrae/deploy
# * **Originally by:** https://github.com/visionmedia/deploy





# ## Usage
usage() {
  cat <<-EOF

  Usage: deploy [options] <env> <command>

  Options:

    -C, --chdir <path>    change the working directory to <path>
    -c, --config <path>   set config path. defaults to ./deploy.conf
    -V, --version         output program version
    -h, --help            output help information

  Commands:

    <env> setup              run remote setup commands
    <env> ref [ref]          deploy a release (commit, branch or tag)
    [env] config [key]       output config file, a section, or one value
    <env> config-all [key]   output all values of a config key in an environment
    <env> console [path]     open an ssh session to the host
    <env> exec <cmd>         execute the given command on the host
    <env> list               list previous deploy commits
    update                   update this script to the latest version

  Examples:

    deploy prod setup             run remote setup in the prod env
    deploy dev ref master         deploy the master branch in the dev env
    deploy prod exec pm2 status   run 'pm2 status' in the prod env
    deploy dev config user        get the value of the user key in the dev env

EOF
}





# ## Sub-commands

# ### `<env> setup`
#
# Perform first-time setup tasks before deployment.
setup() {
  local path="$(get_last_config_value path)"
  local repo="$(get_last_config_value repo)"

  # Run user-defined `pre-setup` hooks (if any).
  hooks pre-setup "$path"

  # Create the `releases` and `tmp` directories in the deployment directory
  # if they don't already exist.
  log running setup
  run "{ test -d $path || exit 1; } \
       && mkdir -p $path/releases $path/tmp" \
    || abort "failed to set up directories; make sure $path exists and is writable"

  # Clone the repository into `repo` in the deployment directory
  # if it isn't already there.
  log cloning repo
  run "test -d $path/repo \
       || { git clone --bare $repo $path/repo || exit 1; }" \
    || abort "failed to clone repo"

  # Run user-defined `post-setup` hooks (if any).
  hooks post-setup "$path"

  log setup complete
}

# ### `<env> ref [ref]`
#
# Deploys the latest changes from the repository.
deploy_ref() {
  local path=`get_last_config_value path`
  local release=`date -u '+%Y-%m-%d-%H-%M-%S'`
  local current_dir="$path/current"
  local release_dir="$path/releases/$release"
  local tmp_dir="$path/tmp"

  # A Git reference to a commit, branch or tag is required,
  # either from the command line argument or from a `ref` key in the configuration file.
  local ref=${1:-`get_last_config_value ref`}
  test -n "$ref" || abort "no commit, branch or tag specified"

  log deploying
  echo "    ref: $ref"
  echo "    release: $release"

  # Run user-defined pre-deploy hooks (if any).
  hooks pre-deploy $current_dir

  # Fetch the latest changes from the repository (from the specified ref).
  log fetching updates
  run "cd $path/repo \
       && git fetch origin '+refs/heads/*:refs/heads/*' \
       && git rev-list -n 1 $ref" \
    || abort "could not fetch changes"

  # Extract the sources at the specified ref into the `releases` directory.
  log "extracting source at $ref"
  run "cd $path/repo \
       && mkdir -p $release_dir \
       && git archive --output $tmp_dir/release-$release.tar $ref \
       && tar -C $release_dir -x --file $tmp_dir/release-$release.tar \
       && rm -f $tmp_dir/release-*.tar" \
    || abort "could not extract source from repository"

  # Run user-defined deploy hooks (if any).
  hooks deploy $release_dir

  # Link the `current` directory to the new release.
  log linking current
  run "ln -fns $release_dir $current_dir" \
    || abort "could not create current symlink"

  # Run user-defined post-deploy hooks (if any).
  hooks post-deploy $current_dir

  log successfully deployed
}

# ### `[env] config [key]`
#
# Prints configuration values.
#
#     # deploy.conf
#     []
#     user dev
#
#     [production]
#     user root
#     port 222
config() {
  # If called with **no environment and no arguments**, print the whole configuration file:
  #
  # ```sh
  # # shell
  # deploy config
  # #=> []
  # #=> user dev
  # #=>
  # #=> [production]
  # #=> user root
  # #=> port 222
  # ```
  if test $# -eq 0; then
    if test -z "$DEPLOY_ENV"; then
      cat "$DEPLOY_CONFIG"

    # If **preceded by the environment**, print all values in that section:
    #
    # ```sh
    # # shell
    # deploy production config
    # #=> user root
    # #=> port 222
    # ```
    else
      get_config_section "$DEPLOY_ENV"
    fi

  # If called with **the environment and a key**, print the last value of that key in that section:
  #
  # ```sh
  # # shell
  # deploy production config user
  # #=> root
  # ```
  else
    get_last_config_value $1
  fi
}

# ### `<env> config-all <key>`
#
# Outputs all values of a config key in the current environment and its inherited environments.
#
#     # deploy.conf
#     []
#     user dev
#
#     [production]
#     user root
#     port 222
#
# ```sh
# # shell
# deploy production config-all user
# #=> dev
# #=> root
# ```
config_all() {
  get_all_config_values "$1"
}

# ### `<env> console [path]`
#
# Launches an interactive ssh console session.
console() {

  # If an **absolute path** is given, the session starts there.
  local path="$1"

  # If **no path** is given, the session starts in the deployment directory.
  if test -z "$path"; then
    path="$(get_last_config_value path)"

  # If a **relative path** is given, it starts there relative to the deployment directory.
  elif [[ ! "$path" =~ ^\/ ]]; then
    path="$(get_last_config_value path)/$path"
  fi

  test -n "$path" || abort "path is required"

  local shell="`build_ssh_command`"
  echo $shell
  $shell -t "cd $path; \$SHELL -il"
}





# ## General options

# ### `--config <path>`
#
# `./deploy.conf` is used as the configuration file by default.
# Use this option or the `$DEPLOY_CONFIG` environment variable to load a different file.
#
# The option takes precedence over the environment variable.
set_config_path() {
  test -f "$1" || abort "invalid --config <path> (no such file)"
  DEPLOY_CONFIG="$1"
}

# ### `--version`
#
# Prints the current version and exits.
version() {
  echo $VERSION
}





# ## Internal implementation

# ### `config_section_exists $env`
#
# Checks whether the config file contains a section with the specified name.
# Returns a non-zero status code if it doesn't.
#
#     # deploy.conf
#     [development]
#     host example
#
# ```sh
# # script
# config_section_exists development
# echo $? #=> 0
# config_section_exists production
# echo $? #=> 1
# ```
config_section_exists() {
  grep "^\[$1\]$" "$DEPLOY_CONFIG" &> /dev/null
}

# ### `get_config_env_var $key`
#
# Gets the environment variable that can be used to add
# a value to the specified config key.
#
# ```sh
# # script
# get_config_env_var path
# #=> DEPLOY_PATH
# get_config_env_var post-setup
# #=> DEPLOY_POST_SETUP
# ```
get_config_env_var() {
  local key=$1
  echo "DEPLOY_$key" | tr '-' '_' | tr '[a-z]' '[A-Z]'
}

# ### `get_last_config_value $key`
#
# Gets the last value of a config key in the current environment and its inherited environments.
#
#     # deploy.conf
#     []
#     user dev
#
#     [production]
#     user root
#
# ```sh
# # script
# get_last_config_value host production
# #=> root
# ```
get_last_config_value() {

  local key=$1
  local env_var=$(get_config_env_var $key)

  local env_var_value=${!env_var}
  if [ -n "$env_var_value" ]; then
    echo "$env_var_value"
  else
    test -n "$key" \
      && get_all_config_values "$key" \
      | tail -n 1
  fi
}

# ### `get_all_config_values $key`
#
# Gets all values of a config key in the current environment and its inherited environments.
#
#     # deploy.conf
#     [development]
#     deploy do-stuff
#     deploy do-more-stuff
#     deploy just-do-it
#
# ```sh
# # script
# get_all_config_values deploy development
# #=> do-stuff
# #=> do-more-stuff
# #=> just-do-it
# ```
get_all_config_values() {

  local env=$DEPLOY_ENV
  local key=$1

  test -n "$env" \
    && test -n "$key" \
    && get_config_values_recursive $key $env
}

# ### `get_config_values_recursive $key $env`
#
# Recursively gets all values of a config key for an environment and its inherited environments.
# Used by `get_all_config_values`.
#
#     # deploy.conf
#     []
#     deploy do-stuff
#
#     [common]
#     deploy do-more-stuff
#     deploy do-stuff-again
#
#     [shared]
#     inherits common
#     deploy do-shared-stuff
#
#     [development]
#     inherits common
#     inherits shared
#     deploy just-do-it
#
# ```sh
# # script
# get_config_values_recursive deploy development
# #=> do-stuff
# #=> do-more-stuff
# #=> do-stuff-again
# #=> just-do-it
# ```
get_config_values_recursive() {

  local key="$1"
  local env="$2"
  local values=

  if ! config_section_exists $env; then
    echo_color $COLOR_RED "    [$env] config section not defined" 1>&2
    exit 0
  fi

  local new_line=$'\n'
  local old_ifs=$IFS
  IFS=$'\n'

  local inherits="$(get_config_values_in_env inherits $env)"
  for inherit_env in $inherits; do
    IFS="$old_ifs"

    local new_values="$(get_config_values_recursive $key $inherit_env)"
    if test -n "$new_values"; then
      [ -n "$values" ] && values="$values$new_line"
      values="$values$new_values"
    fi

    IFS=$'\n'
  done

  IFS="$old_ifs"

  if test -z "$inherits"; then
    local top_level_values="$(get_config_values_in_env $key)"
    if test -n "$top_level_values"; then
      [ -n "$values" ] && values="$new_line$values"
      values="$top_level_values$values"
    fi
  fi

  local current_level_values="$(get_config_values_in_env $key $env)"
  if test -n "$current_level_values"; then
    [ -n "$values" ] && values="$values$new_line"
    values="$values$current_level_values"
  fi

  echo "$values"
}

# ### `get_config_values_in_env $key $env`
#
# Gets all values of a config key for an environment:
#
#     # deploy.conf
#     [development]
#     host foo
#     port 42
#     host bar
#
# ```sh
# # script
# get_config_values_in_env host development
# #=> foo
# #=> bar
# ```
get_config_values_in_env() {

  local key="$1"
  local env="$2"

  get_config_section $env \
    | grep "^$key " \
    | cut -d ' ' -f 2-999
}

# ### `get_config_section $env`
#
# Gets all key/value pairs in a config section, with all comments and empty lines omitted:
#
#     # deploy.conf
#     [development]
#
#     host foo
#     # SSH port
#     port 42
#     user dev
#
# ```sh
# # script
# get_config_section development
# #=> host foo
# #=> port 42
# #=> user dev
# ```
get_config_section() {

  local env="$1"

  grep "^\[$env\]$" -A 999 "$DEPLOY_CONFIG" \
    | tail -n +2 \
    | grep -v "^ *#" \
    | grep -v "^ *$" \
    | sed "/^\[/q" \
    | sed "/^\[/d"
}

# ### `build_ssh_command`
#
# Builds an SSH command to connect to the host.
build_ssh_command() {
  local host=$(get_last_config_value host)
  test -n "$host" || abort "no host config found in environment $DEPLOY_ENV"

  local url=$host

  local user=$(get_last_config_value user)
  if test -n "$user"; then
    url="$user@$url"
  fi

  local key="`get_last_config_value key`"
  local forward_agent="`get_last_config_value forward-agent`"
  local port="`get_last_config_value port`"
  local needs_tty="`get_last_config_value needs_tty`"

  test -n "$forward_agent" && local agent="-A"
  test -n "$key" && local identity="-i $key"
  test -n "$port" && local port="-p $port"
  test -n "$needs_tty" && local tty="-t"
  echo "ssh $tty $agent $port $identity $url"
}

# ### `echo_color $color $message`
#
# Prints a message in the specified color.
echo_color() {
  local color="$1"
  shift
  local message="$@"
  echo -e "\033[${color}m${message}\033[0m"
}

# ### `run $@`
#
# Runs the specified command on the host through SSH.
run() {
  local shell="`build_ssh_command`"
  echo_color 33 "$@" | tr -s ' ' | sed 's/^/    /'
  $shell $@
}

# Returns the command used to export the user's environment
env_command() {
  local path=`get_last_config_value path`
  echo "export ROOT_DIR=$path $(env_variables)"
}

env_variables() {
  local env="$(echo `get_all_config_values env`|sed 's/\n/ /g')"

  for forward_env in $(echo `get_all_config_values forward-env`|sed 's/\n/ /g'); do
    env="$env $forward_env=$(echo "${!forward_env}"|sed 's/ /\\ /g')"
  done

  echo "$env"
}

# Execute hook(s) <name> relative to the path configured
hooks() {

  local hook=$1
  test -n "$hook" || abort hook name required

  local dir=$2
  test -n "$dir" || abort working directory required

  local path=`get_last_config_value path`
  local commands=`get_all_config_values $hook`

  log hook $hook

  if test -n "$commands"; then
    local old_ifs=$IFS
    IFS=$'\n'

    for cmd in $(echo "$commands"); do
      IFS="$old_ifs"

      run "cd $dir \
           && export ROOT_DIR=$path $(env_variables) \
           && $cmd 2>&1" \
        || abort $hook hook failed

      IFS=$'\n'
    done

    IFS="$old_ifs"
  else
    echo "    nothing to do"
  fi
}

# List deploys
list_deploys() {
  local path=`get_last_config_value path`
  run "ls -1 $path/releases"
}

# Require environment arg
require_env() {
  test -z "$DEPLOY_ENV" && abort "<env> required"
  config_section_exists $DEPLOY_ENV || abort "[$DEPLOY_ENV] config section not defined"
}

# Ensure all changes are committed and pushed before deploying
check_for_local_changes() {
  git --no-pager diff --exit-code --quiet || abort "commit or stash your changes before deploying"
  git --no-pager diff --exit-code --quiet --cached || abort "commit your staged changes before deploying"
  [ -z "`git rev-list @{upstream}.. -n 1`" ] || abort "push your changes before deploying"
}

deploy_tmp() {
  DEPLOY_TMP_DIR="$(mktemp -d -t deploy)"
  echo "$DEPLOY_TMP_DIR"
}

update() {
  log "updating deploy from $UPDATE_REPO"

  local tmp_dir=`deploy_tmp`
  cd "$tmp_dir" \
    && git clone $UPDATE_REPO "$tmp_dir" \
    && make install \
    || abort could not update deploy

  log "updated $VERSION -> `./bin/deploy --version`"
}

# Abort with <msg>
abort() {
  echo
  echo_color $COLOR_RED "  $@" 1>&2
  echo
  exit 1
}

cleanup() {
  test -n "$DEPLOY_TMP_DIR" && test -d "$DEPLOY_TMP_DIR" && rm -fr "$DEPLOY_TMP_DIR"
}

# Log <msg>
log() {
  echo
  echo_color $COLOR_BOLD "  ○ $@"
}

main() {
  trap cleanup EXIT

  # Source environment file if present
  [ -f .env ] && . .env

  COLOR_BOLD=1
  COLOR_RED=31
  COLOR_YELLOW=33

  VERSION="1.0.1"
  DEPLOY_ENV=

  UPDATE_REPO=git://github.com/AlphaHydrae/deploy.git
  DEPLOY_TMP_DIR=

  if test -z "$DEPLOY_CONFIG"; then
    DEPLOY_CONFIG=./deploy.conf
  fi

  # Parse arguments
  while test $# -ne 0; do
    arg=$1; shift
    case $arg in
      -h|--help) usage; exit ;;
      -V|--version) version; exit ;;
      -c|--config) set_config_path $1; shift ;;
      -C|--chdir) log cd $1; cd $1; shift ;;
      exec) require_env; run "cd `get_last_config_value path`/current && $(env_command) && $@"; exit ;;
      console) require_env; console $1; exit ;;
      setup) require_env; setup $@; exit ;;
      list) require_env; list_deploys; exit ;;
      ref) require_env; check_for_local_changes; deploy_ref $1; exit ;;
      update) update; exit ;;
      config) config $@; exit ;;
      config-all) require_env; config_all $@; exit;;
      *)
        if test -z "$DEPLOY_ENV"; then
          DEPLOY_ENV=$arg;
        else
          abort "unknown command or option $arg"
        fi
        ;;
    esac
  done

  usage
  abort "no command given"
}

main "$@"
