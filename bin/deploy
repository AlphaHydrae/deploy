#!/usr/bin/env bash

#
# deploy(1) - Shell script to deploy Git repositories
# Released under the MIT License
#
# https://github.com/AlphaHydrae/deploy
# Inspired by https://github.com/visionmedia/deploy
#

COLOR_BOLD=1
COLOR_RED=31
COLOR_YELLOW=33

VERSION="1.0.0"
CONFIG=./deploy.conf
ENV=

UPDATE_REPO=git://github.com/AlphaHydrae/deploy.git
DEPLOY_TMP_DIR=

cleanup() {
  test -n "$DEPLOY_TMP_DIR" && test -d "$DEPLOY_TMP_DIR" && rm -fr "$DEPLOY_TMP_DIR"
}

trap cleanup EXIT

#
# Output usage information
#

usage() {
  cat <<-EOF

  Usage: deploy [options] <env> [command]

  Options:

    -C, --chdir <path>   change the working directory to <path>
    -c, --config <path>  set config path. defaults to ./deploy.conf
    -V, --version        output program version
    -h, --help           output help information

  Commands:

    setup                run remote setup commands
    update [ref]         deploy a release (commit, branch or tag)
    config [key]         output config file or [key]
    exec|run <cmd>       execute the given <cmd>
    console              open an ssh session to the host
    list                 list previous deploy commits

EOF
}

#
# Abort with <msg>
#

abort() {
  echo
  echo_color $COLOR_RED "  $@" 1>&2
  echo
  exit 1
}

#
# Log <msg>
#

log() {
  echo
  echo_color $COLOR_BOLD "  â—‹ $@"
}

#
# Set configuration file <path>
#

set_config_path() {
  test -f $1 || abort invalid --config path
  CONFIG=$1
}

#
# Check if config <section> exists
#

config_section() {
  grep "^\[$1\]$" $CONFIG &> /dev/null
}

#
# Get config value by <key>
#

config_get() {
  local key=$1
  test -n "$key" \
    && config_get_multiple "$key" \
    | tail -n 1
}

#
# Get multiple config values by <key>
#

config_get_multiple() {
  local key=$1
  test -n "$key" \
    && grep "^\[$ENV\]$" -A 999 $CONFIG \
    | tail -n +2 \
    | grep -v '^ *#' \
    | sed "/^\[/q" \
    | grep "^$key " \
    | cut -d ' ' -f 2-999
}

#
# Output version
#

version() {
  echo $VERSION
}

#
# Return the ssh command to run
#

ssh_command() {
  local url="`config_get user`@`config_get host`"
  local key="`config_get key`"
  local forward_agent="`config_get forward-agent`"
  local port="`config_get port`"
  local needs_tty="`config_get needs_tty`"

  test -n "$forward_agent" && local agent="-A"
  test -n "$key" && local identity="-i $key"
  test -n "$port" && local port="-p $port"
  test -n "$needs_tty" && local tty="-t"
  echo "ssh $tty $agent $port $identity $url"
}

#
# Use <color> to print <msg...>
#

echo_color() {
  local color="$1"
  shift
  local message="$@"
  echo -e "\033[${color}m${message}\033[0m"
}

#
# Run the given remote <cmd>
#

run() {
  local shell="`ssh_command`"
  echo_color 33 "$@" | tr -s ' ' | sed 's/^/    /'
  $shell $@
}

#
# Launch an interactive ssh console session
#

console() {
  local path="`config_get path`/current"
  local shell="`ssh_command`"
  echo $shell
  $shell -t "cd $path; \$SHELL -il"
}

#
# Output config or [key]
#

config() {
  if test $# -eq 0; then
    cat $CONFIG
  else
    config_get $1
  fi
}

#
# Returns the command used to export the user's environment
#

env_command() {

  local path=`config_get path`
  local env="$(echo `config_get_multiple env`|sed 's/\n/ /g')"

  echo "export PATH=$path $env"
}

#
# Execute hook(s) <name> relative to the path configured
#

hooks() {

  local hook=$1
  test -n "$hook" || abort hook name required

  local dir=$2
  test -n "$dir" || abort working directory required

  local path=`config_get path`
  local env="$(echo `config_get_multiple env`|sed 's/\n/ /g')"
  local commands=`config_get_multiple $hook`

  log hook $hook

  if test -n "$commands"; then
    local old_ifs=$IFS
    IFS=$'\n'

    for cmd in $(echo "$commands"); do
      IFS="$old_ifs"

      run "cd $dir \
           && export ROOT_DIR=$path $env \
           && $cmd 2>&1" \
        || abort $hook hook failed

      IFS=$'\n'
    done

    IFS="$old_ifs"
  else
    echo "    nothing to do"
  fi
}

#
# Run setup
#

setup() {
  local path=`config_get path`
  local repo=`config_get repo`

  hooks pre-setup $path

  log running setup
  run "{ test -d $path || exit 1; } \
       && mkdir -p $path/releases $path/tmp" \
    || abort "failed to set up directories; make sure $path exists and is writable"

  log cloning repo
  run "test -d $path/repo \
       || { git clone --bare $repo $path/repo || exit 1; }" \
    || abort "failed to clone repo"

  hooks post-setup $path

  log setup complete
}

#
# Deploy [ref]
#

deploy() {

  local ref=$1
  test -n "$ref" || abort no commit, branch or tag specified

  local path=`config_get path`
  local release=`date -u '+%Y-%m-%d-%H-%M-%S'`

  local current_dir="$path/current"
  local release_dir="$path/releases/$release"
  local tmp_dir="$path/tmp"

  log deploying
  echo "    ref: $ref"
  echo "    release: $release"

  hooks pre-deploy $current_dir

  log fetching updates
  run "cd $path/repo \
       && git fetch origin '+refs/heads/*:refs/heads/*' \
       && git rev-list -n 1 $ref" \
    || abort could not fetch changes

  log "extracting source at $ref"
  run "cd $path/repo \
       && mkdir -p $release_dir \
       && git archive --output $tmp_dir/release-$release.tar $ref \
       && tar -C $release_dir -x --file $tmp_dir/release-$release.tar \
       && rm -f $tmp_dir/release-*.tar" \
    || abort could not extract source from repository

  hooks deploy $release_dir

  log linking current
  run "ln -fns $release_dir $current_dir" \
    || abort could not create current symlink

  hooks post-deploy $current_dir

  log successfully deployed
}

#
# List deploys
#

list_deploys() {
  local path=`config_get path`
  run "ls -1 $path/releases"
}

#
# Require environment arg
#

require_env() {
  config_section $ENV || abort "[$ENV] config section not defined"
  test -z "$ENV" && abort "<env> required"
}

#
# Ensure all changes are committed and pushed before deploying
#

check_for_local_changes() {
  git --no-pager diff --exit-code --quiet          || abort "commit or stash your changes before deploying"
  git --no-pager diff --exit-code --quiet --cached || abort "commit your staged changes before deploying"
  [ -z "`git rev-list @{upstream}.. -n 1`" ]       || abort "push your changes before deploying"
}

deploy_tmp() {
  DEPLOY_TMP_DIR="$(mktemp -d -t deploy)"
  echo "$DEPLOY_TMP_DIR"
}

update() {
  log "updating deploy from $UPDATE_REPO"

  local tmp_dir=`deploy_tmp`
  cd "$tmp_dir" \
    && git clone $UPDATE_REPO "$tmp_dir" \
    && make install \
    || abort could not update deploy

  log "updated $VERSION -> `./bin/deploy --version`"
}

# Parse arguments

while test $# -ne 0; do
  arg=$1; shift
  case $arg in
    -h|--help) usage; exit ;;
    -V|--version) version; exit ;;
    -c|--config) set_config_path $1; shift ;;
    -C|--chdir) log cd $1; cd $1; shift ;;
    run|exec) require_env; run "cd `config_get path`/current && $(env_command) && $@"; exit ;;
    console) require_env; console; exit ;;
    setup) require_env; setup $@; exit ;;
    list) require_env; list_deploys; exit ;;
    ref) require_env; check_for_local_changes; deploy "${1:-`config_get ref`}"; exit ;;
    update) update; exit ;;
    config) config $@; exit ;;
    *)
      if test -z "$ENV"; then
        ENV=$arg;
      else
        abort "unknown command or option $arg"
      fi
      ;;
  esac
done

abort "no command given"
